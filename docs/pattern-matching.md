# Pattern Matching

Switches on many numbers are compiled to sequences of simple switch expressions:
```py
  # These two are equivalent
  switch n {
    0: A
    1: B
    2: C
    _: (D n-3)
  }

  switch n {
    0: A
    _: switch n-1 = n-1 {
      0: B
      _: switch n-2 = n-1-1 {
        0: C
        _: use n-3 = n-2-1; (D n-3)
      }
    }
  }
```

Matches on ADT constructors are compiled to different expressions depending on the chosen encoding:
```py
type Maybe = (Some val) | None

UnwrapOrZero x = match x {
  Some: x.val
  None: 0
}

# If the current encoding is 'adt-num-scott' it becomes:
Some = λval λx (x 0 val)
None = λx (x 1)
UnwrapOrZero x = (x λtag switch tag {
  0: λx.val x.val
  _: λ* 0
})

# Otherwise, if the current encoding is 'adt-scott' it becomes:
Some = λval λSome λNone (Some val)
None = λSome λNone None
UnwrapOrZero x = (x λx.val x.val 0)
```

### Pattern Matching functions

Besides `match`and `switch` terms, Bend also supports equational-style pattern matching functions.

```py
And True  b = b
And False * = False
```

There are advantages and disadvantages to using this syntax.
They offer more advanced pattern matching capabilities and also take care linearizing variables to make sure that recursive definitions work correctly in strict evaluation mode, but take away your control of how the pattern matching is implemented and can be a bit more resource intensive in some cases.

Pattern matching equations are transformed into a tree of `match` and `switch` terms from left to right.
```py
# These two are equivalent
(Foo 0 false (Cons h1 (Cons h2 t))) = (Bar h1 h2 t)
(Foo 0 * *) = Baz
(Foo n false *) = n
(Foo * true *) = 0

Foo = λarg1 λarg2 λarg3 (switch arg1 {
  0: λarg2 λarg3 match arg2 {
    true: λarg3 Baz
    false: λarg3 match arg3 {
      Cons: (match arg3.tail {
        Cons: λarg3.head (A arg3.head arg3.tail.head arg3.tail.tail)
        Nil: λarg3.head Baz
      } arg3.head)
      Nil: Baz
    }
  }
  _: λarg2 λarg3 (match arg2 {
    true: λarg1-1 0
    false: λarg1-1 (+ arg1-1 0)
  } arg1-1)
} arg2 arg3)
```
Besides the compilation of complex pattern matching into simple `match` and `switch` expressions, this example also shows how some arguments are pushed inside the match.
When compiling for strict evaluation, by default any variables that are used inside a match get linearized by adding a lambda in each arm and an application passing its value inwards.
To ensure that recursive pattern matching functions don't loop in strict mode, it's necessary to make the match arms combinators, so that they can be converted into separate functions and a lazy reference is used in the match arm.
```py
# This is what the Foo function actually compiles to.
# With -Olinearize-matches and -Ofloat-combinators (default on strict mode)
(Foo__C0) = λ* λa λb λc (Bar c a b)

(Foo__C5) = λa switch a { 0: λ* Baz; _: Foo__C4; }   # Foo.case_0
(Foo__C4) = λ* λa (a Foo__C3)                      # Foo.case_0.case_false
(Foo__C3) = λa switch a { 0: Bar; _: Foo__C2; }      # Part of cons pattern matching
(Foo__C2) = λ* λa λb (b Foo__C1 a)                 # Foo.case_0.case_false.case_cons
(Foo__C1) = λa switch a { 0: λ* Baz; _: Foo__C0; }   # Part of cons pattern matching
(Foo__C0) = λ* λa λb λc (Bar c a b)                  # Foo.case_0.case_false.case_cons.case_cons

(Foo__C6) = λ* λa (+ a 0)                          # Foo.case_+.case_false
(Foo__C7) = λa switch a { 0: λ* 0; _: Foo__C6; }   # Part of bool pattern matching
(Foo__C9) = λa λb λ* (b Foo__C7 a)                 # Foo.case_+
(Foo__C8) = λa λ* (a Foo__C5)                     # Part of main pattern matching
# As an user, you can't write a function with __ on its name, that sequence is reserved for things generated by the compiler.
```

Pattern matching equations also support matching on non-consecutive numbers:
```rust
Parse '(' = Token.LParenthesis
Parse ')' = Token.RParenthesis
Parse 'λ' = Token.Lambda
Parse  n  = (Token.Name n)
```
The compiler transforms this into an optimized cascade of switch expressions. Each switch computes the distance from the smallest character to efficiently test each case:
```py
Parse = λarg0 switch matched = (- arg0 '(') {
  0: Token.LParenthesis
  # ')' + 1 - '(' is resolved during compile time
  _: switch matched = (- matched-1 ( ')'-1-'(' ) {
    0: Token.RParenthesis
    _: switch matched = (- matched-1 ( 'λ'-1-')' ) {
      0: Token.Lambda
      _: use n = (+ 1 matched-1); (Token.Name n)
    }
  }
}
```
Unlike with `switch`, with pattern matching equations you can't access the value of the predecessor of the matched value directly, but instead you can match on a variable. Instead, variables (like n above) are bound to computed expressions based on the matched value.
Notice how in the example above, `n` is bound to `(+ 1 matched-1)`.

Notice that this definition is valid, since `*` will cover both `p` and `0` cases when the first argument is `False`.This example shows how patterns are considered from top to bottom, with wildcards covering multiple specific cases:
```rust
pred_if False * if_false = if_false
pred_if True  p *        = (- p 1)
pred_if True  0 *        = 0
```

Pattern matching on strings and lists desugars to a list of matches on Cons and Nil

```py
Hi "hi" = 1
Hi _ = 0

Foo [] = 0
Foo [x] = x
Foo _ = 3

# Becomes:
Hi (String/Cons 'h' (String/Cons 'i' String/Nil)) = 2
Hi _ = 0

Foo List.nil = 0
Foo (List.cons x List.nil) = x
Foo _ = 3
```
